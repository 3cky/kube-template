// Copyright Â© 2015-2018 Victor Antonovich <victor@antonovich.me>
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Code generated by "go:generate go run cmd/genclient/main.go". DO NOT EDIT.

package main

import (
	"context"
	"errors"
	"fmt"
	"sort"

	corev1 "k8s.io/api/core/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/labels"
	"k8s.io/client-go/listers/core/v1"
	"k8s.io/client-go/tools/cache"

	"github.com/golang/glog"
)

func (c *Client) Pods(namespace, selector string) ([]corev1.Pod, error) {
	glog.V(4).Infof("fetching pods, namespace: %q, selector: %q", namespace, selector)

	var pods []corev1.Pod

	if c.useInformers {
		c.Lock()
		defer c.Unlock()

		key := fmt.Sprintf("pods(%s)", namespace)

		podLister, found := c.listers[key]

		if !found {
			podInformer := c.informerFactory(namespace).Core().V1().Pods()

			podLister = podInformer.Lister()

			c.listers[key] = podLister

			go podInformer.Informer().Run(c.stopCh)

			if synced := cache.WaitForCacheSync(c.stopCh, podInformer.Informer().HasSynced); !synced {
				return nil, errors.New("pod cache sync failed")
			}
		}

		s, err := labels.Parse(selector)
		if err != nil {
			return nil, err
		}

		es, err := podLister.(v1.PodLister).Pods(namespace).List(s)
		if err != nil {
			return nil, err
		}

		for _, e := range es {
			pods = append(pods, *e)
		}
	} else {
		options := metav1.ListOptions{LabelSelector: selector}

		podList, err := c.kubeClient.CoreV1().Pods(namespace).List(context.TODO(), options)
		if err != nil {
			return nil, err
		}

		pods = podList.Items
	}

	// Make list order stable
	sort.Slice(pods, func(i, j int) bool {
		return pods[i].Name < pods[j].Name
	})

	return pods, nil
}

func (c *Client) Services(namespace, selector string) ([]corev1.Service, error) {
	glog.V(4).Infof("fetching services, namespace: %q, selector: %q", namespace, selector)

	var services []corev1.Service

	if c.useInformers {
		c.Lock()
		defer c.Unlock()

		key := fmt.Sprintf("services(%s)", namespace)

		serviceLister, found := c.listers[key]

		if !found {
			serviceInformer := c.informerFactory(namespace).Core().V1().Services()

			serviceLister = serviceInformer.Lister()

			c.listers[key] = serviceLister

			go serviceInformer.Informer().Run(c.stopCh)

			if synced := cache.WaitForCacheSync(c.stopCh, serviceInformer.Informer().HasSynced); !synced {
				return nil, errors.New("service cache sync failed")
			}
		}

		s, err := labels.Parse(selector)
		if err != nil {
			return nil, err
		}

		es, err := serviceLister.(v1.ServiceLister).Services(namespace).List(s)
		if err != nil {
			return nil, err
		}

		for _, e := range es {
			services = append(services, *e)
		}
	} else {
		options := metav1.ListOptions{LabelSelector: selector}

		serviceList, err := c.kubeClient.CoreV1().Services(namespace).List(context.TODO(), options)
		if err != nil {
			return nil, err
		}

		services = serviceList.Items
	}

	// Make list order stable
	sort.Slice(services, func(i, j int) bool {
		return services[i].Name < services[j].Name
	})

	return services, nil
}

func (c *Client) ReplicationControllers(namespace, selector string) ([]corev1.ReplicationController, error) {
	glog.V(4).Infof("fetching replicationcontrollers, namespace: %q, selector: %q", namespace, selector)

	var replicationcontrollers []corev1.ReplicationController

	if c.useInformers {
		c.Lock()
		defer c.Unlock()

		key := fmt.Sprintf("replicationcontrollers(%s)", namespace)

		replicationcontrollerLister, found := c.listers[key]

		if !found {
			replicationcontrollerInformer := c.informerFactory(namespace).Core().V1().ReplicationControllers()

			replicationcontrollerLister = replicationcontrollerInformer.Lister()

			c.listers[key] = replicationcontrollerLister

			go replicationcontrollerInformer.Informer().Run(c.stopCh)

			if synced := cache.WaitForCacheSync(c.stopCh, replicationcontrollerInformer.Informer().HasSynced); !synced {
				return nil, errors.New("replicationcontroller cache sync failed")
			}
		}

		s, err := labels.Parse(selector)
		if err != nil {
			return nil, err
		}

		es, err := replicationcontrollerLister.(v1.ReplicationControllerLister).ReplicationControllers(namespace).List(s)
		if err != nil {
			return nil, err
		}

		for _, e := range es {
			replicationcontrollers = append(replicationcontrollers, *e)
		}
	} else {
		options := metav1.ListOptions{LabelSelector: selector}

		replicationcontrollerList, err := c.kubeClient.CoreV1().ReplicationControllers(namespace).List(context.TODO(), options)
		if err != nil {
			return nil, err
		}

		replicationcontrollers = replicationcontrollerList.Items
	}

	// Make list order stable
	sort.Slice(replicationcontrollers, func(i, j int) bool {
		return replicationcontrollers[i].Name < replicationcontrollers[j].Name
	})

	return replicationcontrollers, nil
}

func (c *Client) Events(namespace, selector string) ([]corev1.Event, error) {
	glog.V(4).Infof("fetching events, namespace: %q, selector: %q", namespace, selector)

	var events []corev1.Event

	if c.useInformers {
		c.Lock()
		defer c.Unlock()

		key := fmt.Sprintf("events(%s)", namespace)

		eventLister, found := c.listers[key]

		if !found {
			eventInformer := c.informerFactory(namespace).Core().V1().Events()

			eventLister = eventInformer.Lister()

			c.listers[key] = eventLister

			go eventInformer.Informer().Run(c.stopCh)

			if synced := cache.WaitForCacheSync(c.stopCh, eventInformer.Informer().HasSynced); !synced {
				return nil, errors.New("event cache sync failed")
			}
		}

		s, err := labels.Parse(selector)
		if err != nil {
			return nil, err
		}

		es, err := eventLister.(v1.EventLister).Events(namespace).List(s)
		if err != nil {
			return nil, err
		}

		for _, e := range es {
			events = append(events, *e)
		}
	} else {
		options := metav1.ListOptions{LabelSelector: selector}

		eventList, err := c.kubeClient.CoreV1().Events(namespace).List(context.TODO(), options)
		if err != nil {
			return nil, err
		}

		events = eventList.Items
	}

	// Make list order stable
	sort.Slice(events, func(i, j int) bool {
		return events[i].Name < events[j].Name
	})

	return events, nil
}

func (c *Client) Endpoints(namespace, selector string) ([]corev1.Endpoints, error) {
	glog.V(4).Infof("fetching endpoints, namespace: %q, selector: %q", namespace, selector)

	var endpoints []corev1.Endpoints

	if c.useInformers {
		c.Lock()
		defer c.Unlock()

		key := fmt.Sprintf("endpoints(%s)", namespace)

		endpointsLister, found := c.listers[key]

		if !found {
			endpointsInformer := c.informerFactory(namespace).Core().V1().Endpoints()

			endpointsLister = endpointsInformer.Lister()

			c.listers[key] = endpointsLister

			go endpointsInformer.Informer().Run(c.stopCh)

			if synced := cache.WaitForCacheSync(c.stopCh, endpointsInformer.Informer().HasSynced); !synced {
				return nil, errors.New("endpoints cache sync failed")
			}
		}

		s, err := labels.Parse(selector)
		if err != nil {
			return nil, err
		}

		es, err := endpointsLister.(v1.EndpointsLister).Endpoints(namespace).List(s)
		if err != nil {
			return nil, err
		}

		for _, e := range es {
			endpoints = append(endpoints, *e)
		}
	} else {
		options := metav1.ListOptions{LabelSelector: selector}

		endpointsList, err := c.kubeClient.CoreV1().Endpoints(namespace).List(context.TODO(), options)
		if err != nil {
			return nil, err
		}

		endpoints = endpointsList.Items
	}

	// Make list order stable
	sort.Slice(endpoints, func(i, j int) bool {
		return endpoints[i].Name < endpoints[j].Name
	})

	return endpoints, nil
}

func (c *Client) Nodes(selector string) ([]corev1.Node, error) {
	glog.V(4).Infof("fetching nodes, selector: %q", selector)

	var nodes []corev1.Node

	if c.useInformers {
		c.Lock()
		defer c.Unlock()

		key := fmt.Sprintf("nodes()")

		nodeLister, found := c.listers[key]

		if !found {
			nodeInformer := c.informerFactory("").Core().V1().Nodes()

			nodeLister = nodeInformer.Lister()

			c.listers[key] = nodeLister

			go nodeInformer.Informer().Run(c.stopCh)

			if synced := cache.WaitForCacheSync(c.stopCh, nodeInformer.Informer().HasSynced); !synced {
				return nil, errors.New("node cache sync failed")
			}
		}

		s, err := labels.Parse(selector)
		if err != nil {
			return nil, err
		}

		es, err := nodeLister.(v1.NodeLister).List(s)
		if err != nil {
			return nil, err
		}

		for _, e := range es {
			nodes = append(nodes, *e)
		}
	} else {
		options := metav1.ListOptions{LabelSelector: selector}

		nodeList, err := c.kubeClient.CoreV1().Nodes().List(context.TODO(), options)
		if err != nil {
			return nil, err
		}

		nodes = nodeList.Items
	}

	// Make list order stable
	sort.Slice(nodes, func(i, j int) bool {
		return nodes[i].Name < nodes[j].Name
	})

	return nodes, nil
}

func (c *Client) Namespaces(selector string) ([]corev1.Namespace, error) {
	glog.V(4).Infof("fetching namespaces, selector: %q", selector)

	var namespaces []corev1.Namespace

	if c.useInformers {
		c.Lock()
		defer c.Unlock()

		key := fmt.Sprintf("namespaces()")

		namespaceLister, found := c.listers[key]

		if !found {
			namespaceInformer := c.informerFactory("").Core().V1().Namespaces()

			namespaceLister = namespaceInformer.Lister()

			c.listers[key] = namespaceLister

			go namespaceInformer.Informer().Run(c.stopCh)

			if synced := cache.WaitForCacheSync(c.stopCh, namespaceInformer.Informer().HasSynced); !synced {
				return nil, errors.New("namespace cache sync failed")
			}
		}

		s, err := labels.Parse(selector)
		if err != nil {
			return nil, err
		}

		es, err := namespaceLister.(v1.NamespaceLister).List(s)
		if err != nil {
			return nil, err
		}

		for _, e := range es {
			namespaces = append(namespaces, *e)
		}
	} else {
		options := metav1.ListOptions{LabelSelector: selector}

		namespaceList, err := c.kubeClient.CoreV1().Namespaces().List(context.TODO(), options)
		if err != nil {
			return nil, err
		}

		namespaces = namespaceList.Items
	}

	// Make list order stable
	sort.Slice(namespaces, func(i, j int) bool {
		return namespaces[i].Name < namespaces[j].Name
	})

	return namespaces, nil
}

func (c *Client) ComponentStatuses(selector string) ([]corev1.ComponentStatus, error) {
	glog.V(4).Infof("fetching componentstatuses, selector: %q", selector)

	var componentstatuses []corev1.ComponentStatus

	if c.useInformers {
		c.Lock()
		defer c.Unlock()

		key := fmt.Sprintf("componentstatuses()")

		componentstatusLister, found := c.listers[key]

		if !found {
			componentstatusInformer := c.informerFactory("").Core().V1().ComponentStatuses()

			componentstatusLister = componentstatusInformer.Lister()

			c.listers[key] = componentstatusLister

			go componentstatusInformer.Informer().Run(c.stopCh)

			if synced := cache.WaitForCacheSync(c.stopCh, componentstatusInformer.Informer().HasSynced); !synced {
				return nil, errors.New("componentstatus cache sync failed")
			}
		}

		s, err := labels.Parse(selector)
		if err != nil {
			return nil, err
		}

		es, err := componentstatusLister.(v1.ComponentStatusLister).List(s)
		if err != nil {
			return nil, err
		}

		for _, e := range es {
			componentstatuses = append(componentstatuses, *e)
		}
	} else {
		options := metav1.ListOptions{LabelSelector: selector}

		componentstatusList, err := c.kubeClient.CoreV1().ComponentStatuses().List(context.TODO(), options)
		if err != nil {
			return nil, err
		}

		componentstatuses = componentstatusList.Items
	}

	// Make list order stable
	sort.Slice(componentstatuses, func(i, j int) bool {
		return componentstatuses[i].Name < componentstatuses[j].Name
	})

	return componentstatuses, nil
}

func (c *Client) ConfigMaps(namespace, selector string) ([]corev1.ConfigMap, error) {
	glog.V(4).Infof("fetching configmaps, namespace: %q, selector: %q", namespace, selector)

	var configmaps []corev1.ConfigMap

	if c.useInformers {
		c.Lock()
		defer c.Unlock()

		key := fmt.Sprintf("configmaps(%s)", namespace)

		configmapLister, found := c.listers[key]

		if !found {
			configmapInformer := c.informerFactory(namespace).Core().V1().ConfigMaps()

			configmapLister = configmapInformer.Lister()

			c.listers[key] = configmapLister

			go configmapInformer.Informer().Run(c.stopCh)

			if synced := cache.WaitForCacheSync(c.stopCh, configmapInformer.Informer().HasSynced); !synced {
				return nil, errors.New("configmap cache sync failed")
			}
		}

		s, err := labels.Parse(selector)
		if err != nil {
			return nil, err
		}

		es, err := configmapLister.(v1.ConfigMapLister).ConfigMaps(namespace).List(s)
		if err != nil {
			return nil, err
		}

		for _, e := range es {
			configmaps = append(configmaps, *e)
		}
	} else {
		options := metav1.ListOptions{LabelSelector: selector}

		configmapList, err := c.kubeClient.CoreV1().ConfigMaps(namespace).List(context.TODO(), options)
		if err != nil {
			return nil, err
		}

		configmaps = configmapList.Items
	}

	// Make list order stable
	sort.Slice(configmaps, func(i, j int) bool {
		return configmaps[i].Name < configmaps[j].Name
	})

	return configmaps, nil
}

func (c *Client) LimitRanges(namespace, selector string) ([]corev1.LimitRange, error) {
	glog.V(4).Infof("fetching limitranges, namespace: %q, selector: %q", namespace, selector)

	var limitranges []corev1.LimitRange

	if c.useInformers {
		c.Lock()
		defer c.Unlock()

		key := fmt.Sprintf("limitranges(%s)", namespace)

		limitrangeLister, found := c.listers[key]

		if !found {
			limitrangeInformer := c.informerFactory(namespace).Core().V1().LimitRanges()

			limitrangeLister = limitrangeInformer.Lister()

			c.listers[key] = limitrangeLister

			go limitrangeInformer.Informer().Run(c.stopCh)

			if synced := cache.WaitForCacheSync(c.stopCh, limitrangeInformer.Informer().HasSynced); !synced {
				return nil, errors.New("limitrange cache sync failed")
			}
		}

		s, err := labels.Parse(selector)
		if err != nil {
			return nil, err
		}

		es, err := limitrangeLister.(v1.LimitRangeLister).LimitRanges(namespace).List(s)
		if err != nil {
			return nil, err
		}

		for _, e := range es {
			limitranges = append(limitranges, *e)
		}
	} else {
		options := metav1.ListOptions{LabelSelector: selector}

		limitrangeList, err := c.kubeClient.CoreV1().LimitRanges(namespace).List(context.TODO(), options)
		if err != nil {
			return nil, err
		}

		limitranges = limitrangeList.Items
	}

	// Make list order stable
	sort.Slice(limitranges, func(i, j int) bool {
		return limitranges[i].Name < limitranges[j].Name
	})

	return limitranges, nil
}

func (c *Client) PersistentVolumes(selector string) ([]corev1.PersistentVolume, error) {
	glog.V(4).Infof("fetching persistentvolumes, selector: %q", selector)

	var persistentvolumes []corev1.PersistentVolume

	if c.useInformers {
		c.Lock()
		defer c.Unlock()

		key := fmt.Sprintf("persistentvolumes()")

		persistentvolumeLister, found := c.listers[key]

		if !found {
			persistentvolumeInformer := c.informerFactory("").Core().V1().PersistentVolumes()

			persistentvolumeLister = persistentvolumeInformer.Lister()

			c.listers[key] = persistentvolumeLister

			go persistentvolumeInformer.Informer().Run(c.stopCh)

			if synced := cache.WaitForCacheSync(c.stopCh, persistentvolumeInformer.Informer().HasSynced); !synced {
				return nil, errors.New("persistentvolume cache sync failed")
			}
		}

		s, err := labels.Parse(selector)
		if err != nil {
			return nil, err
		}

		es, err := persistentvolumeLister.(v1.PersistentVolumeLister).List(s)
		if err != nil {
			return nil, err
		}

		for _, e := range es {
			persistentvolumes = append(persistentvolumes, *e)
		}
	} else {
		options := metav1.ListOptions{LabelSelector: selector}

		persistentvolumeList, err := c.kubeClient.CoreV1().PersistentVolumes().List(context.TODO(), options)
		if err != nil {
			return nil, err
		}

		persistentvolumes = persistentvolumeList.Items
	}

	// Make list order stable
	sort.Slice(persistentvolumes, func(i, j int) bool {
		return persistentvolumes[i].Name < persistentvolumes[j].Name
	})

	return persistentvolumes, nil
}

func (c *Client) PersistentVolumeClaims(namespace, selector string) ([]corev1.PersistentVolumeClaim, error) {
	glog.V(4).Infof("fetching persistentvolumeclaims, namespace: %q, selector: %q", namespace, selector)

	var persistentvolumeclaims []corev1.PersistentVolumeClaim

	if c.useInformers {
		c.Lock()
		defer c.Unlock()

		key := fmt.Sprintf("persistentvolumeclaims(%s)", namespace)

		persistentvolumeclaimLister, found := c.listers[key]

		if !found {
			persistentvolumeclaimInformer := c.informerFactory(namespace).Core().V1().PersistentVolumeClaims()

			persistentvolumeclaimLister = persistentvolumeclaimInformer.Lister()

			c.listers[key] = persistentvolumeclaimLister

			go persistentvolumeclaimInformer.Informer().Run(c.stopCh)

			if synced := cache.WaitForCacheSync(c.stopCh, persistentvolumeclaimInformer.Informer().HasSynced); !synced {
				return nil, errors.New("persistentvolumeclaim cache sync failed")
			}
		}

		s, err := labels.Parse(selector)
		if err != nil {
			return nil, err
		}

		es, err := persistentvolumeclaimLister.(v1.PersistentVolumeClaimLister).PersistentVolumeClaims(namespace).List(s)
		if err != nil {
			return nil, err
		}

		for _, e := range es {
			persistentvolumeclaims = append(persistentvolumeclaims, *e)
		}
	} else {
		options := metav1.ListOptions{LabelSelector: selector}

		persistentvolumeclaimList, err := c.kubeClient.CoreV1().PersistentVolumeClaims(namespace).List(context.TODO(), options)
		if err != nil {
			return nil, err
		}

		persistentvolumeclaims = persistentvolumeclaimList.Items
	}

	// Make list order stable
	sort.Slice(persistentvolumeclaims, func(i, j int) bool {
		return persistentvolumeclaims[i].Name < persistentvolumeclaims[j].Name
	})

	return persistentvolumeclaims, nil
}

func (c *Client) PodTemplates(namespace, selector string) ([]corev1.PodTemplate, error) {
	glog.V(4).Infof("fetching podtemplates, namespace: %q, selector: %q", namespace, selector)

	var podtemplates []corev1.PodTemplate

	if c.useInformers {
		c.Lock()
		defer c.Unlock()

		key := fmt.Sprintf("podtemplates(%s)", namespace)

		podtemplateLister, found := c.listers[key]

		if !found {
			podtemplateInformer := c.informerFactory(namespace).Core().V1().PodTemplates()

			podtemplateLister = podtemplateInformer.Lister()

			c.listers[key] = podtemplateLister

			go podtemplateInformer.Informer().Run(c.stopCh)

			if synced := cache.WaitForCacheSync(c.stopCh, podtemplateInformer.Informer().HasSynced); !synced {
				return nil, errors.New("podtemplate cache sync failed")
			}
		}

		s, err := labels.Parse(selector)
		if err != nil {
			return nil, err
		}

		es, err := podtemplateLister.(v1.PodTemplateLister).PodTemplates(namespace).List(s)
		if err != nil {
			return nil, err
		}

		for _, e := range es {
			podtemplates = append(podtemplates, *e)
		}
	} else {
		options := metav1.ListOptions{LabelSelector: selector}

		podtemplateList, err := c.kubeClient.CoreV1().PodTemplates(namespace).List(context.TODO(), options)
		if err != nil {
			return nil, err
		}

		podtemplates = podtemplateList.Items
	}

	// Make list order stable
	sort.Slice(podtemplates, func(i, j int) bool {
		return podtemplates[i].Name < podtemplates[j].Name
	})

	return podtemplates, nil
}

func (c *Client) ResourceQuotas(namespace, selector string) ([]corev1.ResourceQuota, error) {
	glog.V(4).Infof("fetching resourcequotas, namespace: %q, selector: %q", namespace, selector)

	var resourcequotas []corev1.ResourceQuota

	if c.useInformers {
		c.Lock()
		defer c.Unlock()

		key := fmt.Sprintf("resourcequotas(%s)", namespace)

		resourcequotaLister, found := c.listers[key]

		if !found {
			resourcequotaInformer := c.informerFactory(namespace).Core().V1().ResourceQuotas()

			resourcequotaLister = resourcequotaInformer.Lister()

			c.listers[key] = resourcequotaLister

			go resourcequotaInformer.Informer().Run(c.stopCh)

			if synced := cache.WaitForCacheSync(c.stopCh, resourcequotaInformer.Informer().HasSynced); !synced {
				return nil, errors.New("resourcequota cache sync failed")
			}
		}

		s, err := labels.Parse(selector)
		if err != nil {
			return nil, err
		}

		es, err := resourcequotaLister.(v1.ResourceQuotaLister).ResourceQuotas(namespace).List(s)
		if err != nil {
			return nil, err
		}

		for _, e := range es {
			resourcequotas = append(resourcequotas, *e)
		}
	} else {
		options := metav1.ListOptions{LabelSelector: selector}

		resourcequotaList, err := c.kubeClient.CoreV1().ResourceQuotas(namespace).List(context.TODO(), options)
		if err != nil {
			return nil, err
		}

		resourcequotas = resourcequotaList.Items
	}

	// Make list order stable
	sort.Slice(resourcequotas, func(i, j int) bool {
		return resourcequotas[i].Name < resourcequotas[j].Name
	})

	return resourcequotas, nil
}

func (c *Client) Secrets(namespace, selector string) ([]corev1.Secret, error) {
	glog.V(4).Infof("fetching secrets, namespace: %q, selector: %q", namespace, selector)

	var secrets []corev1.Secret

	if c.useInformers {
		c.Lock()
		defer c.Unlock()

		key := fmt.Sprintf("secrets(%s)", namespace)

		secretLister, found := c.listers[key]

		if !found {
			secretInformer := c.informerFactory(namespace).Core().V1().Secrets()

			secretLister = secretInformer.Lister()

			c.listers[key] = secretLister

			go secretInformer.Informer().Run(c.stopCh)

			if synced := cache.WaitForCacheSync(c.stopCh, secretInformer.Informer().HasSynced); !synced {
				return nil, errors.New("secret cache sync failed")
			}
		}

		s, err := labels.Parse(selector)
		if err != nil {
			return nil, err
		}

		es, err := secretLister.(v1.SecretLister).Secrets(namespace).List(s)
		if err != nil {
			return nil, err
		}

		for _, e := range es {
			secrets = append(secrets, *e)
		}
	} else {
		options := metav1.ListOptions{LabelSelector: selector}

		secretList, err := c.kubeClient.CoreV1().Secrets(namespace).List(context.TODO(), options)
		if err != nil {
			return nil, err
		}

		secrets = secretList.Items
	}

	// Make list order stable
	sort.Slice(secrets, func(i, j int) bool {
		return secrets[i].Name < secrets[j].Name
	})

	return secrets, nil
}

func (c *Client) ServiceAccounts(namespace, selector string) ([]corev1.ServiceAccount, error) {
	glog.V(4).Infof("fetching serviceaccounts, namespace: %q, selector: %q", namespace, selector)

	var serviceaccounts []corev1.ServiceAccount

	if c.useInformers {
		c.Lock()
		defer c.Unlock()

		key := fmt.Sprintf("serviceaccounts(%s)", namespace)

		serviceaccountLister, found := c.listers[key]

		if !found {
			serviceaccountInformer := c.informerFactory(namespace).Core().V1().ServiceAccounts()

			serviceaccountLister = serviceaccountInformer.Lister()

			c.listers[key] = serviceaccountLister

			go serviceaccountInformer.Informer().Run(c.stopCh)

			if synced := cache.WaitForCacheSync(c.stopCh, serviceaccountInformer.Informer().HasSynced); !synced {
				return nil, errors.New("serviceaccount cache sync failed")
			}
		}

		s, err := labels.Parse(selector)
		if err != nil {
			return nil, err
		}

		es, err := serviceaccountLister.(v1.ServiceAccountLister).ServiceAccounts(namespace).List(s)
		if err != nil {
			return nil, err
		}

		for _, e := range es {
			serviceaccounts = append(serviceaccounts, *e)
		}
	} else {
		options := metav1.ListOptions{LabelSelector: selector}

		serviceaccountList, err := c.kubeClient.CoreV1().ServiceAccounts(namespace).List(context.TODO(), options)
		if err != nil {
			return nil, err
		}

		serviceaccounts = serviceaccountList.Items
	}

	// Make list order stable
	sort.Slice(serviceaccounts, func(i, j int) bool {
		return serviceaccounts[i].Name < serviceaccounts[j].Name
	})

	return serviceaccounts, nil
}
