// Copyright Â© 2015-2018 Victor Antonovich <victor@antonovich.me>
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Code generated by "go:generate go run cmd/genclient/main.go". DO NOT EDIT.

package main

import (
	"errors"
	"sort"

	corev1 "k8s.io/api/core/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/labels"
	"k8s.io/client-go/listers/core/v1"
	"k8s.io/client-go/tools/cache"

	"github.com/golang/glog"
)

func (c *Client) Pods(namespace, selector string) ([]corev1.Pod, error) {
	glog.V(4).Infof("fetching pods, namespace: %q, selector: %q", namespace, selector)

	var pods []corev1.Pod

	if c.useInformers {
		c.RLock()
		defer c.RUnlock()

		podLister, found := c.listers["podLister"]

		if !found {
			podInformer := c.informerFactory.Core().V1().Pods()

			podLister = podInformer.Lister()

			c.listers["podLister"] = podLister

			go podInformer.Informer().Run(c.stopCh)

			if synced := cache.WaitForCacheSync(c.stopCh, podInformer.Informer().HasSynced); !synced {
				return nil, errors.New("pod cache sync failed")
			}
		}

		s, err := labels.Parse(selector)
		if err != nil {
			return nil, err
		}

		es, err := podLister.(v1.PodLister).Pods(namespace).List(s)
		if err != nil {
			return nil, err
		}

		for _, e := range es {
			pods = append(pods, *e)
		}
	} else {
		options := metav1.ListOptions{LabelSelector: selector}

		podList, err := c.kubeClient.CoreV1().Pods(namespace).List(options)
		if err != nil {
			return nil, err
		}

		pods = podList.Items
	}

	// Make list order stable
	sort.Slice(pods, func(i, j int) bool {
		return pods[i].Name < pods[j].Name
	})

	return pods, nil
}

func (c *Client) Services(namespace, selector string) ([]corev1.Service, error) {
	glog.V(4).Infof("fetching services, namespace: %q, selector: %q", namespace, selector)

	var services []corev1.Service

	if c.useInformers {
		c.RLock()
		defer c.RUnlock()

		serviceLister, found := c.listers["serviceLister"]

		if !found {
			serviceInformer := c.informerFactory.Core().V1().Services()

			serviceLister = serviceInformer.Lister()

			c.listers["serviceLister"] = serviceLister

			go serviceInformer.Informer().Run(c.stopCh)

			if synced := cache.WaitForCacheSync(c.stopCh, serviceInformer.Informer().HasSynced); !synced {
				return nil, errors.New("service cache sync failed")
			}
		}

		s, err := labels.Parse(selector)
		if err != nil {
			return nil, err
		}

		es, err := serviceLister.(v1.ServiceLister).Services(namespace).List(s)
		if err != nil {
			return nil, err
		}

		for _, e := range es {
			services = append(services, *e)
		}
	} else {
		options := metav1.ListOptions{LabelSelector: selector}

		serviceList, err := c.kubeClient.CoreV1().Services(namespace).List(options)
		if err != nil {
			return nil, err
		}

		services = serviceList.Items
	}

	// Make list order stable
	sort.Slice(services, func(i, j int) bool {
		return services[i].Name < services[j].Name
	})

	return services, nil
}

func (c *Client) ReplicationControllers(namespace, selector string) ([]corev1.ReplicationController, error) {
	glog.V(4).Infof("fetching replicationcontrollers, namespace: %q, selector: %q", namespace, selector)

	var replicationcontrollers []corev1.ReplicationController

	if c.useInformers {
		c.RLock()
		defer c.RUnlock()

		replicationcontrollerLister, found := c.listers["replicationcontrollerLister"]

		if !found {
			replicationcontrollerInformer := c.informerFactory.Core().V1().ReplicationControllers()

			replicationcontrollerLister = replicationcontrollerInformer.Lister()

			c.listers["replicationcontrollerLister"] = replicationcontrollerLister

			go replicationcontrollerInformer.Informer().Run(c.stopCh)

			if synced := cache.WaitForCacheSync(c.stopCh, replicationcontrollerInformer.Informer().HasSynced); !synced {
				return nil, errors.New("replicationcontroller cache sync failed")
			}
		}

		s, err := labels.Parse(selector)
		if err != nil {
			return nil, err
		}

		es, err := replicationcontrollerLister.(v1.ReplicationControllerLister).ReplicationControllers(namespace).List(s)
		if err != nil {
			return nil, err
		}

		for _, e := range es {
			replicationcontrollers = append(replicationcontrollers, *e)
		}
	} else {
		options := metav1.ListOptions{LabelSelector: selector}

		replicationcontrollerList, err := c.kubeClient.CoreV1().ReplicationControllers(namespace).List(options)
		if err != nil {
			return nil, err
		}

		replicationcontrollers = replicationcontrollerList.Items
	}

	// Make list order stable
	sort.Slice(replicationcontrollers, func(i, j int) bool {
		return replicationcontrollers[i].Name < replicationcontrollers[j].Name
	})

	return replicationcontrollers, nil
}

func (c *Client) Events(namespace, selector string) ([]corev1.Event, error) {
	glog.V(4).Infof("fetching events, namespace: %q, selector: %q", namespace, selector)

	var events []corev1.Event

	if c.useInformers {
		c.RLock()
		defer c.RUnlock()

		eventLister, found := c.listers["eventLister"]

		if !found {
			eventInformer := c.informerFactory.Core().V1().Events()

			eventLister = eventInformer.Lister()

			c.listers["eventLister"] = eventLister

			go eventInformer.Informer().Run(c.stopCh)

			if synced := cache.WaitForCacheSync(c.stopCh, eventInformer.Informer().HasSynced); !synced {
				return nil, errors.New("event cache sync failed")
			}
		}

		s, err := labels.Parse(selector)
		if err != nil {
			return nil, err
		}

		es, err := eventLister.(v1.EventLister).Events(namespace).List(s)
		if err != nil {
			return nil, err
		}

		for _, e := range es {
			events = append(events, *e)
		}
	} else {
		options := metav1.ListOptions{LabelSelector: selector}

		eventList, err := c.kubeClient.CoreV1().Events(namespace).List(options)
		if err != nil {
			return nil, err
		}

		events = eventList.Items
	}

	// Make list order stable
	sort.Slice(events, func(i, j int) bool {
		return events[i].Name < events[j].Name
	})

	return events, nil
}

func (c *Client) Endpoints(namespace, selector string) ([]corev1.Endpoints, error) {
	glog.V(4).Infof("fetching endpoints, namespace: %q, selector: %q", namespace, selector)

	var endpoints []corev1.Endpoints

	if c.useInformers {
		c.RLock()
		defer c.RUnlock()

		endpointsLister, found := c.listers["endpointsLister"]

		if !found {
			endpointsInformer := c.informerFactory.Core().V1().Endpoints()

			endpointsLister = endpointsInformer.Lister()

			c.listers["endpointsLister"] = endpointsLister

			go endpointsInformer.Informer().Run(c.stopCh)

			if synced := cache.WaitForCacheSync(c.stopCh, endpointsInformer.Informer().HasSynced); !synced {
				return nil, errors.New("endpoints cache sync failed")
			}
		}

		s, err := labels.Parse(selector)
		if err != nil {
			return nil, err
		}

		es, err := endpointsLister.(v1.EndpointsLister).Endpoints(namespace).List(s)
		if err != nil {
			return nil, err
		}

		for _, e := range es {
			endpoints = append(endpoints, *e)
		}
	} else {
		options := metav1.ListOptions{LabelSelector: selector}

		endpointsList, err := c.kubeClient.CoreV1().Endpoints(namespace).List(options)
		if err != nil {
			return nil, err
		}

		endpoints = endpointsList.Items
	}

	// Make list order stable
	sort.Slice(endpoints, func(i, j int) bool {
		return endpoints[i].Name < endpoints[j].Name
	})

	return endpoints, nil
}

func (c *Client) Nodes(selector string) ([]corev1.Node, error) {
	glog.V(4).Infof("fetching nodes, selector: %q", selector)

	var nodes []corev1.Node

	if c.useInformers {
		c.RLock()
		defer c.RUnlock()

		nodeLister, found := c.listers["nodeLister"]

		if !found {
			nodeInformer := c.informerFactory.Core().V1().Nodes()

			nodeLister = nodeInformer.Lister()

			c.listers["nodeLister"] = nodeLister

			go nodeInformer.Informer().Run(c.stopCh)

			if synced := cache.WaitForCacheSync(c.stopCh, nodeInformer.Informer().HasSynced); !synced {
				return nil, errors.New("node cache sync failed")
			}
		}

		s, err := labels.Parse(selector)
		if err != nil {
			return nil, err
		}

		es, err := nodeLister.(v1.NodeLister).List(s)
		if err != nil {
			return nil, err
		}

		for _, e := range es {
			nodes = append(nodes, *e)
		}
	} else {
		options := metav1.ListOptions{LabelSelector: selector}

		nodeList, err := c.kubeClient.CoreV1().Nodes().List(options)
		if err != nil {
			return nil, err
		}

		nodes = nodeList.Items
	}

	// Make list order stable
	sort.Slice(nodes, func(i, j int) bool {
		return nodes[i].Name < nodes[j].Name
	})

	return nodes, nil
}

func (c *Client) Namespaces(selector string) ([]corev1.Namespace, error) {
	glog.V(4).Infof("fetching namespaces, selector: %q", selector)

	var namespaces []corev1.Namespace

	if c.useInformers {
		c.RLock()
		defer c.RUnlock()

		namespaceLister, found := c.listers["namespaceLister"]

		if !found {
			namespaceInformer := c.informerFactory.Core().V1().Namespaces()

			namespaceLister = namespaceInformer.Lister()

			c.listers["namespaceLister"] = namespaceLister

			go namespaceInformer.Informer().Run(c.stopCh)

			if synced := cache.WaitForCacheSync(c.stopCh, namespaceInformer.Informer().HasSynced); !synced {
				return nil, errors.New("namespace cache sync failed")
			}
		}

		s, err := labels.Parse(selector)
		if err != nil {
			return nil, err
		}

		es, err := namespaceLister.(v1.NamespaceLister).List(s)
		if err != nil {
			return nil, err
		}

		for _, e := range es {
			namespaces = append(namespaces, *e)
		}
	} else {
		options := metav1.ListOptions{LabelSelector: selector}

		namespaceList, err := c.kubeClient.CoreV1().Namespaces().List(options)
		if err != nil {
			return nil, err
		}

		namespaces = namespaceList.Items
	}

	// Make list order stable
	sort.Slice(namespaces, func(i, j int) bool {
		return namespaces[i].Name < namespaces[j].Name
	})

	return namespaces, nil
}
